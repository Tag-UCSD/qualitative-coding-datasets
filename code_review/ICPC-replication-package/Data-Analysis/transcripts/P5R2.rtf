{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww22440\viewh26260\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs28 \cf0 REVIEW TYPE AND GOAL\
Draft re-review of API proposition\
Overall check whether the API can be stable and constant for the future\
\
CONTEXT\
- Deployment service for the back-end from P5R1\
- Also upstream but no big community around it - mostly driven by the company and their devs\
- Fairly young code base, everything in flux, less rules and guidelines\
- It\'92s a deployment code, upstream, so they do not have to worry about the code you see\
- The people who work on it are there from the start so a lot of the context is in the head of the people\
- The project is younger and therefore more changeable. They are still experimenting, trying things around. They have time to change how things are done.\
- The speed of development is much faster than in P5R1 - they are making a product and it can be faster because it is less code, less legacy, easier to change. It is possible to fundamentally challenge the whole architecture still.\
- Knows that what is going to change here will be fundamentally different in half a year again.\
- Saw this proposal before but had a look at it only from the top view - the external API level that others will consume and not into the implementation details.\
- Decided to do the reviews top to bottom and left some significant comments before. Didn\'92t want to go deeper as the reviewer asked for higher level changes and the deeper things will change.\
- This was maybe a month ago. The author changed things now, hopefully based on the given feedback and asked for a re-review.\
- Wants to again start from the top - needs to load the context which he lost most of it over the month - will do so through looking at their previous comments and trying to build up the same view had before and see whether the change moved in a good direction. Also wants to understand whether the new state makes sense and the future the reviewer envisioned was meaningful. Maybe it just doesn\'92t look that good.\
- Has many open PRs in the project that are not dependent on this change but somehow interfering with it. Uses that to perform the review to see whether this one or his changes should change further.\
\
\
TRANSCRIPT\
- Scrolls down through the conversation. It has a merge conflict. That does not matter as the reviewer has no intention of merging it right now. This review will not go all the way down to the deep implementation - that would take a whole day and the reviewer will split the review in phases.\
- If the external API and big picture look OK, the reviewer will leave a positive feedback on that part and say that they will have a look at the next part after a break. Maybe couple of days later.\
- Scrolls back up and starts reading own comments.\
- The first one relates to the other open PRs - the reviewer was happy that one of his PRs can be simplified and asked for some more information on the code base in general which would help that task. Then the reviewer solved this issue with the reviewer that replied to their comment and merged that PR later.\
- As it was settled, the reviewer can leave a comment that some parts of the change are already unnecessary. The last line related to the previous comment stays relevant.\
- Says the GitHub interface is less familiar for them so it is harder to navigate this.\
- Decides to find the lines of code in the current version of the PR to leave their comment.\
- Goes to Files tab. Uses the left bar outline to find the relevant file. Says GitHub does not show their comments so it is harder to find and the reviewer does not like it.\
- The reviewer could  leave their comment there but it would miss the context of their previous comment do goes back to the Conversation tab which they consider less visible police to put that comment.\
- Writes a reply in the thread of the old comment that the issue mentioned in it was already addressed and merged and some other related work happened. Says the reviewer thinks they are good in this area after rebase. That comment solved itself by solving the other PR.\
- Marks the comment as resolved.\
- Sees that the rest of their previous comments are marked by the author as resolved signalling to the reviewer that their comments were addressed probably.\
- Extends one by one to read what they contained.\
- The reviewer would like to see the differences in the Patch sets with their comments but it is hard to get that from GitHub. In Gerrit that is very easy to do.\
- The reviewer guesses that a version pushed to the branch before their comments were added is probably the one they reviewed. There is a compare button but the reviewer is not sure whether that is something they really want to see. Looks at it and scrolls through it. Concludes it is probably not it as it is not enough of changes or all changes that happened since their last review. Probably difference between what the reviewer reviewed already and the next version rather than the current state.\
- DOesn\'92t want to spend time trying to figure out how to see what they want to see.\
- Will do what they usually do. Opens in a next tab the Files which compare the current version and Main. In the other tab they will still look at the comments in the Conversation tab and see where is the comment and manually diffing it with the current version of the pull-request.\
- Next comment was pointing to an obvious copy-paste issue in a repetitive in-line comment.\
- Tries to click on the name of the file in the header of their old comment hoping that it will open the correct place to check how the change was implemented. It opens the File view, however not in the place where the reviewer commented and the comments are still not visible. The reviewer just returns back to the conversation. Copies the name of the variable and searches for it in the other open tab. Ones back to the conversation to assure what was the problem they commented on. The issue was fixed.\
- Goes back to the conversation - collapses the current comment and extends the next one.\
- The comment was asking a bit deeper question about how they want to handle a certain implementation also pointing to the next comment for more context.\
- Goes to see the next comment which questioned whether something needs to be externally exposed and expects that that part was probably just removed.\
- Switches to the other tab. Uses the outline to find the correct file. Checks the line number in the Conversation tab and goes to check the spot in the other tab.\
- Interestingly, it is still there even though the reviewer commented that it is not needed and the comment was resolved. This endpoint of the API is not really needed.\
- Decides to double-check whether they are looking at the current version of the PR. Reopens the PR and goes to the Files tab. If it is like that, there is something fishy. Finds the correct file and confirms the endpoint is still there.\
- Wants to be more explicit on the topic, so adds a comment asking the author to talk in some real-time channel, irc, video meeting or similar. Either the author disagrees with the comment but did not say so or the common case is the author pressed resolved before removing it and then forgot about it. Maybe the author had some comments to express but forgot to express it.\
- Adds a comment reinforcing that they still think it is not necessary. Realises that they could check whether that field is used somewhere in the implementation which could inform them why is it needed. Cops the name of the field. Finds the file where it would be used in the outline and searches for the field name. It did not find. Realises they might be in the wrong file. Then finds out the correct file was there, but they missed it as they would need to load the diff. Complains about GitHub interface again. If there would be a change in the file, they would see it in the outline but in the diff part it is collapsed so it is easy to miss a lot of changed code and searching is not possible.\
- Loads the diff, finds out the field is not used which means it is probably still removable and the author doesn\'92t need this and probably just missed to remove it.\
- Finds the file where they started writing their comment before and cannot find it again. Probably because they did not save it before. Creates a new comment saying they still think it is not a needd field and they do not see it used anywhere. Says directly Lets remove it. Also adds an invitation to ping them on slack to discuss it further if needed. Adds the comment and starts the review.\
- The reviewer tried to be more explicit. Before in the first review their comment was saying they don\'92t think the field is needed, but now they are pretty sure it is not needed so they wanted to be explicit and say \'93Lets remove this\'94 while giving the possibility to discuss it further\
- In the scenario when they leave a comment they expect a comment to come back or see that the comment was resolved based on the comment. The worst is when the author resolved the comment but forgot to mark it as resolved because then it is hard to figure out whether it was actually resolved. It is OK that the author marked all as resolved and invited for a re-review. Even if the author would not invite for a re-review and mark the comments as resolved, the reviewer can still review it. And this probably happened now, that the author resolved it but forgot to mark it as resolved.\
- Goes back to the Conversation. Expands all the comments to see them. Hides the comment that was discussed just now.\
- Rerads the next comment which was marked as resolved and the author also replied with the direction in which they went with the implementation which is setting the scene for the reviewer. This was one of the major things from the first review so it probably needs more looking into.\
- Goes to the Files tab and locates the correct file. Sees that a new field was implemented. Checks in the docstring that it has two possible fields and it is a required field so that looks OK.\
- Goes back to the Conversation to re-read the comment and says they think that the main change looks OK. Confirms that the author implemented what the reviewer has asked for.\
- Goes back to the files and wants to also see the specs for the implementation of the change which seems OK.\
- The original comment had 2 sub-comments - one was asking to add a field [pointing at it in the Files tab]. Now it is there and that is nice. The other was to extend their existing template where they map fields representation for the users in a template and for the devs in the specs accordingly. So now they have it. They just need to figure out what are the commonalities and specific things for the template and the specs. Sees that a field has been also reused which is also good.\
- Scrolls around looking at the fields in the template and the spec. Checks that there is only a field for the devs in the specs which is also good. The reviewer thinks that it follows the template well.\
- The reviewer makes a note on a paper to check outside of the review the duality of the specs and the template and the common pattern they have because the reviewer has a feeling there is more that they can commonalise. They do not want to do that within the review because the implementation follows the pattern in the code but they might want to redefine the pattern. This is again a thing of the code changing a lot and while they are implementing it they realise it can be done better and they con go back and do it better. This comment was really resolved as the reviewer asked for.\
- Goes to the Conversation. Hides the comment and moved on to the next one.\
- Just reads it and already knows it is OK so just hides it.\
- The next comment is about using the template in a higher level structure. Goes to the relevant file in the File tab. Says - Interesting, some other comments are here, not mine. Needs a bit more context. Clicks few times to expand the context of the diff hunk. So what they now have is a template per cell? Or what is the [string]? When the reviewer reads the template, they do not understand parts of it so the documentation definitely needs and improvement. It does not explain to the user on how to use it. The reviewer knows it because they cannot understand it. Adds a comment asking What is the key of the map and whether it is the name of the driver. The user shouldn\'92t be looking at the implementation to use it so it should be documented well. The reviewer has more ideas about this but will leave it as is.\
- Goes back to the Conversation to re-read the comment. Says the key shouldn\'92t be the driver itself because it exists in the template as a field.\
- Goes back to the Files tab. Re-reads the docstring and notices that it says the field is a list but it defines a map. Edits the comment to be more specific. Says they don\'92t fully understand the field definition which says it is a list but it is a map and that it does not define the key of the map. At least the documentation needs to be improved for the users to understand how to use it. So the reviewer asked for a structural change before that was implemented but new issues were introduced in the process. Once the author replies and explains what the field is about only then the reviewer can understand if there are any issues on that.\
- The next comment was a copy paste issue again in the docstring.\
- Then goes back to their previous comment and notices that their unwritten rule about how they write the docstring is not followed there. They should have an automatic check for it, but it doe snot exist. Edits the comment again. For the formatting issues they normally say it is a Nit: to signify it is not a big deal. Adds a nit: line to the comment asking the author to follow the documentation and reminds the format.\
- Goes back to the Conversation to read the next comment. When it was written they still had 2 options on how to implement the entity but that is being decided now. SO the reviewer now knows which option should be implemented so the code should probably stay in the way it already was. Goes to check to the Files tab that that is the case which it is.\
- Goes back up to a comment that the author left extended to check again lateral it is a bit more involved. The comment is also dependent on a recent decision but is dependent on a specified condition. Check the condition in the Files tab and concludes it is being followed. The higher level of the issue was fixed and then the reviewer will see how is the implementation. Hides the comment for the moment.\
- This was the last of the previous comments. This phase helped the reviewer to load the context of what issues they saw with the higher level of the API definition. Sees one comment that was not resolved and the rest is done.\
- Next the reviewer wants to check whether the whole higher level API definition is consistent after the changes that the author did. SO they will review only two directory in the whole change. The reviewer also knows more because some decisions have been made in the meantime. The reviewer also realises that this change is affected by another change that they merged recently so when the author rebases it will look different.\
- Starts in a file in the second directory that the reviewer wants to review.\
- Adds a comment to help the author do the rebase of this. The reviewer knows why the conflict is happening so it helps the author to figure out how to solve the conflict. It is \'93one of the merge conflicts caused by the removal of one field\'94. By that the author will know that they can remove all 3 marked lines.\
- The rest of that diff hunk is only lines reformatted due to a go alignment approach which is not helpful for code review.\
- The next hunk uses the new field and the rest of the diff is go reformatted as well.\
- The next hunk also uses the field. The reviewer goes back to check why is it used twice. Says nobody knows. Shows more context of the hunk.\
- It is another issue that the reviewer thinks does not belong in this review but wants to add a comment and then discuss it separately. There is a duplication that probably should not be there.\
- Adds a comment mentioning which lines are duplicated and says that it\'92s fine to follow the same duplication pattern of initialization but it probably should be resolved in a separate PR.\
- The reviewer wants to check the duplication even on this day so writes another TODO note on the paper. It looks like an easy gain which the reviewer can do quickly.\
- Continues scrolling down. Finds it strange that there is another logic duplication. Returns to edit the previous comment to add that line of code in it.\
- Continues down. Identifies a place which was already checked because of their previous comment.\
- The next hunk is just using the previous. Checks the related messages. Has some doubts. Looks at more context of the hunk and is satisfied as the messages follow a pattern so it\'92s fine.\
- Strangely the next logic is not duplicated but wants to check it with the other duplication cases. Lets it be for now and continues.\
- Finds a place which is related to their comment on a map that is not well documented. It is a piece of logic that uses that map but it is still not clear what the key is. The reviewer just wants to wait for what the author replies.\
- Scrolls down. Finds the place where the map is defined. Says that they do not understand it as they do not have the full picture yet.\
- Finds a piece of logic that is also duplicate which is a problem because the duplication of field initialisation from before is also propagating through the logic.\
- Edits the previous comment and signifies with \'93\\\\later\'94 that they are not a magician that knows everything but that they realised something while reviewing so they want to show their mental process. Mentions that they realised the vale is propagated in a duplicated way between the top and bottom level.\
- The author is following a pattern so the reviewer doesn\'92t want to block on this and wants to again improve the pattern separately.\
- Finds another piece of logic. Takes some time to review it thoroughly. Most of it looks OK. The beginning is a bit strange and the reviewer believes it can be simplified.\
- Wants to formulate a comment on that as a question as they are around 70+% sure. Writes that they think they can simplify this by dropping the condition as it should work also without it. Then realises it could cover some specific case so adds another question to the comment on whether that case is something that needs to be handled. If so, then the reviewer would probably still a bit reformulate to only catch that case.\
- Continues scrolling. Remembers the next file was also already checked through a conversation comment.\
- Agrees that a field should be optional as they can initialise it from the environment.\
- Says that the next few fields are again following a pattern.\
- Next field needs to think about how it is implemented and where\
- Next fields were already addressed through the comments from the previous review round.\
- Next field is required with 2 possible values. Wonders if it would make more sense to have an optional field with a default value as the default one is used maybe in 95% of the cases by the users from their knowledge.\
- Adds a comment and says they will probably discuss it with the author and others in the group later in a call to see if to make it optional.\
- Adds a comment saying they think most of the times the user wants to use one case so they could make the field optional with that case as a default. Tags a colleague that is also one of the three people the most active on this type of issues (the three being the author, the reviewer and the third colleague). The tagged colleague has good ideas on this so they want to keep them in the loop.\
- Finds another place with a doc copy-paste issues that the reviewer missed before. Uses the search function to find other cases of the same copy paste. Scrolls through the files until the end of the API specification. Then scrolls up also and finds no other case of the copy paste.\
- Returns to their last comment and continues reviewing checking each field. Saying the fields are part of the pattern. Some needs to think about more.\
- Then finds a field in the internal specs that is related to the potentially optional field. Concludees it is OK that that field stays required for the internal purposes.\
- Shows a resolved comment by another reviewer. Hides it again without a reaction.\
- Finds a part of code with some logic that just skims through and says it is a boilerplate.\
- Finds another copy-paste in the docstring just from a different place.\
- Spends some time to review a basic reconstructor which looks all good\
- Then spends some time to check the logic of the API input validation\
- Realises there is something strange but then sees that another reviewer already left a comment about that (a validation function that is not being used.)\
- Uses the find to identify where is it used and finds it in the higher level. Concludes the issue is a bit more complicated than what it seemed at first.\
- Adds a reply to the other reviewer\'92s comment saying it is more complicated and that the reviewer can check the relevant web hook. However, the other reviewer\'92s comment is related to a broader discussion the team has about thether to allow users to interact with the smaller API as well and that comment is assuming they do.\
- Adds to the comment that the issue depends on what do they allow the user to do. Explains what should happen in case the other reviewer\'92s assumption is true. They could see what they do in other places, try to find if there is a pattern and follow that.\
- The reviewer could check whether the pattern exists but if they ask the other reviewer, they might save some time. It is not the nicest thing to do but it is optimising for throughput. If the other reviewer doesn\'92t know then they will go and check. Because it is a long running debate, the reviewer is a bit burned out on that discussion.\
- The next file is autogenerated so the reviewer will not look at that.\
- That concludes the review of the API definition change. The reviewer also reached a point where they are getting tired so they would get a break now but it\'92s also a good moment to stop.\
- Finishes the review by Comment. The reviewer did a review of the API definition which is definitely improved and they still need to check the tests and the implementation. Writes a review message saying they reviewed the API definition which looks better. There are still some comments but the overall direction is OK.\
- The author is newer in the team but it is a seasoned engineer so the reviewer doesn\'92t have to be that careful about feelings. The reviewer wants to keep the author motivated as they are a fairly new addition to the team and is very motivated so the reviewer doesn\'92t want to loose that motivation.\
\
GENERAL STRATEGY\
Looks only topic wise for the files of the API definition. See whether their previous comments were addressed, check the overall consistency of the top level.\
\
NOTES\
- P2 had a similar problem - difficulty in comparing the state from their last review while seeing their comments\
- The review officially starts when the first comment is added, but P5 was at that point already reviewing for 20 minutes.\
\
\
INTERVIEW\
\
I: It's quite intensive, if there's so many things to check. Is this something common that you do on these huge patches that you set topic focused steps. So now, I'm just having a top view. I look at the API and the external points. And that's it.\
\
P5: Yeah, I have to actually do, because I don't have enough brain power to fit everything into my brain at the same time. So if I start just sequentially going and look at both the API and the implementation. Then I'm run out of the context window in my head. And actually, so so what I do -I just wanted to show that this is like 3,000 lines of more than 3,000 lines of code so it is impossible to fit into my head. So one of the com. One of the things I could do is - because it's split up to like 7 commits I can do commits by commit. I chose not to do so because of the API. I know that there are multiple changes in this commit list affecting the same API definition, and I want to have a consistent view on the end result of the API. So one other way would be to go commit by commit and assume that the commits are fairly well sized. If if I like, that's that's like less than 1,000 per commit definitely. So that's that's easier. But I here I wanted to make it topic wise, because the API is the most crucial part of the change.\
Because that's the hardest thing to change later. If you make a mistake and commit that into implantation, can we can iterate of the implantation without affecting other groups in this project. Because they start depending on the API. If they have to change the API later, they also need to be changed or their implantation needs to be changed. So the API is crucial. I want to keep constant API. So I looked at it that way. Maybe on the implementation side. When looking at the implementation, I will be more specific. I don\'92t know. Because the implantation is in a single block I would say, because we are now introducing a new API entity.\
And this is the definition of it that we reviewed, and there will be an implementation of it that I will review at some point, maybe tomorrow. But also that's fairly self-consistent. We need to be self-consistent in the implementation. So, but there could be changes where the way how the change is built up is more more gradual, in a sense that it is adding a small bit of implementation, and then adding a next small bit of implementation. It's created in a way that is easier to review in isolation.\
I'll see just quickly [looks at the list of commits in the PR]. That's the controller. Yeah, this is not split up that way.\
This is more like fixing review comments as new commits, not splitting up the actual works. I think that's the big, big commit and small fixes under it. So that's not reviewable that way. And I'm wondering if I should ask to split it up, but I probably won't in this specific case ask for the split up because of the API. The split up I would ask for would be, please do an API only commit but I can do that review without having that commit. So that wasn't worth the effort.\
When I look at the implantation if I feel something needs to be split up that needs to be a reusable code for later than I will ask to do that in a separate commit probably.\
So yeah, yeah, so just going back to the original question. It depends on the proposal. When there is an API external interface change as part of the proposal, I tend to review that separately from the implantation, if possible because it helps figuring out finding things what I don't understand on the API definition, and because somebody else needs to understand that API without looking at our implementation, I shouldn't use my implementation knowledge to understand the API. So starting with the API and doing that in isolation helps figuring out those things like missing documentation, for example, or not easy to use as an API user.\
\
I: So this is a bit different process than what you would maybe do in some other cases when it would be split by the commit. You wanted to have sort of a consistent view of the change. So then, you like reviewed also top down basically the API. Did you consider like trying to find the core of the change? Like you actually saw the core of the change in the API but you did not really go for trying to find it.\
\
P5: This is mostly because I had a review on before on this. So I knew that the core of the change is adding a new API entity and the structure. It was a bit more automatic in my head that I knew that what is the change and what is the reason. So the previous review we did on the other project that was totally new to me, so I had to start somewhere to understand it where to start. Here I knew that this exists. I reviewed this before I knew what is the core of the change the new API entity. So I just jumped into that and it wasn't an explicit effort to find that because it was already in my head\
\
I:  You have thought quite a bit about this comment: what is the key of the map in the name of the driver? Right? So like what I see here is a bit that, like you try to identify issues, you comment on it, but you don't necessarily try to understand everything. And, like this - set separate top level review is let's say, the extremity of showcase of that you have very much a limit of what you are attempting to understand or not. So is this something that you would, for example, need to approve the change in the end, to like reach a full understanding of what is happening or what is the limit for you of caring about whether you know or not?\
\
P5: I definitely want to understand this before I approve. It's more like - in this phase of the review. I'll try to not get slowed down by those missing pieces which I don't understand yet. I let the author explain it. That saves me some time figuring out by myself. And because I knew that I probably don't want to go into the details of implementation today I don't need this knowledge answered right now. I need this to be answered before I approve, but I can like live without it today in my review session. Other option would be to check if [author] is online, and try to ping them to get the feedback immediately, and then go over it. But I tend to do the review in isolation, because this is focus time. And if I start discussing with [author] then I will lose focus. We will start growing on time and will lose time. And it's already hard to review this. I don't want to lose time on tangents. Also, I think it's two level of of comments here. So one is. I don't understand this. So this needs some some effort to make it understandable for the API users. That's one of the comments.\
The other is even I don't understand it. Either I can guess what it is, and and try to, you know, build up a guesswork around it, or I say no, I don't want to guess. Let somebody who knows this tell me. Not lose time and effort on guessing or going into the implantation and figure it out by myself.\
It's optimization a bit on my time. If it would be crucial to understandto understand if the API is solid then I would stop there and say, Okay, I don't understand this. And this is affecting the API so much that I need your feedback first, or your answers first, before I can continue. And this is what what happened in the previous review round as I saw issues in the API, where I had a firm feeling that this needs to be changed. And I left those comments and stopped because it will change. So I anyhow need to review it. It doesn't make sense to move forward. And in this particular case I didn't feel that. So I move forward. It is something that even if it's fixed it won't change the overall structure of the API, so it won't cause so much change that I have to start over the review again from the from the top level again.\
\
I: So that quite sounds to me that you are counting on basically having still some iterations.\
\
P5: Yes, definitely. This will take 5 iterations still I think. yes, yes.\
\
I: Does this in any way affect the review I you know you are still going to discuss this?\
\
P5: Yes. As soon as I accumulated enough points to discuss, I stand to decide to not review further, because I know that if I have like 10 points there will be at least one contentious point, and that will maybe change the overall direction of the implementation. Also I started this review run today that I knew I won't finish it today. It's impossible for me to approve this today, even if it's perfect, because I will run out of energy.\
\
I: Because it\'92s so big.\
\
P5: Basically. Yes, yes, it's a gradual process. I will build up context around this change. I will learn why we do - I know why we do this, but how we do this. I will learn that over these iterations. This is a learning process for me as well. It's the problem. So, in a sense if I would have small commits I can approve after review session, and don't have to go back to it. But also these features we do are fairly hard to do in small steps, in a way that the first small steps are approvable before seeing the whole thing. In the other project we reviewed we tend to have small commits and be more focusing on having small commits and approving them gradually. But what we learned, or what I learned over the years that it's helping the reviewers and helping myself as well as an author to have small commits. But still, if you have a feature, that feature will be approved where all the small commits are reviewed. So, there is no real gradual merging of the feature pieces, even though they are small and understandable in isolation, we still commit to the whole feature when we review the whole feature. So this is why I don't really mind if it's big until it is trying to implement a single feature which is consistent. If somebody starts mixing 2 features in the same PR then I will say let's do 2 pull requests for the 2 features, but if it's a single feature, it's a big feature. It can be like 10 commits, and still I would approve it after reading through all the commits, because otherwise I wouldn't be 100% sure that's it's consistent.\
\
I:  So then I think, I have last question on my side at this point. What does it mean for you when you see this like boilerplate code, because how it looks like it's just like, okay, I already know this. I'm not even going to check if it's copied well, let's say.\
\
P5: Yeah. Well most of our boilerplate here is generated by a tool. So there was a big file. I haven't reviewed because the name content generated, and I know that\'92s jointed by a tool, and I don't have to review if that's broken. Then I cannot fix it. Here, I have to fix the tool, and we won't figure it out by looking to the generated code. Probably we will figure out that failure in the test environment. There are some boilerplate that is almost automated, but not 100% generated. Yes, that's hard, because that's noise. And yes, when I when I getting tired or and there's a lot of things to still do today then I skip over this and might miss something. So I would prefer a a system where all the boilerplate is auto generated, and all the things I need to look at is human generated. I mean, generated by somebody that it doesn't have to be human. That could be an AI. But that's like that's something that is specific to this feature and boilerplate. But in a sense that it's there because of the structures we have to build up. And it's always the same, or always very similar, and that just holding up the structure. And it's okay here. So I think the majority of the boilerplate is generated. But the API has some created once edited later, created once by the tool edited by the human later type of code, where we sometimes make mistakes and therefore need to review. So yeah, it's a burden when you have this gray area between fully generated code and manually created code. But that's just what we have to live with I think. If it would be extensive then I would think about how to remove it, but I think it's manageable.\
\
I: Good. Then I'm really happy. Did you by any chance by talking through your process figure out anything about it, what you commonly do or what you don't think about?\
\
P5: Yeah, I think I think finding the core of the change was was something that most the time is fully automatic. And and it's just like looking at what's changing this PR, and then just selecting the biggest change or selecting some known file which tend to be the base part of the system part of the system. Talking about more here, and comparing the previous review and this review how I selected where to start. That was, that was not something I told before it was fairly automatic. I did that without knowing what I'm doing. What else? I think that that was the main learning for me today. That's probably important. Do it, even if I do it automatically.}